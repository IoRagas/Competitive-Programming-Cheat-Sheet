# Competitive Programming Cheat Sheet

Welcome to the Competitive Programming Cheat Sheet repository! This is a comprehensive collection of algorithms, data structures, and problem-solving techniques commonly used in competitive programming.

## üìö Repository Structure

This repository is organized into the following topic folders:

### [01-Graphs](./01-Graphs)
Graph algorithms including BFS, DFS, shortest paths (Dijkstra, Bellman-Ford, Floyd-Warshall), MST (Kruskal, Prim), topological sort, strongly connected components, and more.

### [02-Data-Structures-Basic](./02-Data-Structures-Basic)
Fundamental data structures: arrays, strings, linked lists, stacks, queues, hash tables, and their implementations.

### [03-Data-Structures-Advanced](./03-Data-Structures-Advanced)
Advanced data structures: segment trees, Fenwick trees (BIT), tries, DSU (Union-Find), heaps, splay trees, and specialized tree structures.

### [04-Dynamic-Programming](./04-Dynamic-Programming)
Dynamic programming problems including knapsack, LCS, LIS, matrix chain multiplication, digit DP, bitmask DP, DP on trees, and optimization techniques.

### [05-Mathematics](./05-Mathematics)
Number theory, combinatorics, modular arithmetic, prime algorithms, GCD/LCM, matrix operations, and mathematical problem-solving techniques.

### [06-Game-Theory](./06-Game-Theory)
Game theory concepts including Nim game, Grundy numbers, minimax algorithm, alpha-beta pruning, and optimal game strategies.

### [07-String-Algorithms](./07-String-Algorithms)
String algorithms: KMP, Z-algorithm, Rabin-Karp, suffix arrays, suffix trees, string hashing, Aho-Corasick, and Manacher's algorithm.

### [08-Geometry](./08-Geometry)
Computational geometry: convex hull, line intersection, closest pair, polygon algorithms, sweep line, and 3D geometry.

### [09-Greedy-Algorithms](./09-Greedy-Algorithms)
Greedy algorithms: activity selection, interval scheduling, Huffman coding, fractional knapsack, and job sequencing.

### [10-Sorting-and-Searching](./10-Sorting-and-Searching)
Sorting algorithms (merge sort, quick sort, heap sort, counting sort), binary search variants, two-pointer technique, and sliding window.

## üöÄ How to Use

1. Navigate to the topic folder you're interested in
2. Each folder contains a detailed README with subtopics
3. Add your implementations with proper documentation
4. Include time/space complexity analysis
5. Add example problems and test cases

## ü§ù Contributing

Feel free to contribute by:
- Adding algorithm implementations
- Improving documentation
- Adding problem examples
- Fixing bugs or errors
- Suggesting new topics

## üìù Note

This is a living document. Each topic folder is ready for you to add:
- Code implementations in your preferred language(s)
- Detailed explanations and tutorials
- Practice problems and solutions
- Complexity analysis
- Edge cases and optimization tips

Happy Coding! üéØ